<!-- ****************************************
     |docname| - main template for this theme
     **************************************** -->
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>14.2. Binary Search Trees &#8212; CISC 187 Course Reader Overview</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/accessibility.css?v=50109A2C" />
    <link rel="stylesheet" type="text/css" href="../_static/matrixeq.css?v=58BC228F" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/637.0fa6cababf056764.css?v=F9484CEF" />
    <link rel="stylesheet" type="text/css" href="../_static/runestone.3eb60bc006ae9a54.css?v=3A5A250C" />



    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/animationbase.js?v=A043C3A7"></script>
    <script src="../_static/matrixeq.js?v=D64CFA5A"></script>
    <script src="../_static/runtime.66b619f51b746382.bundle.js?v=C3F69EE5"></script>
    <script src="../_static/637.d54be67956c5c660.bundle.js?v=915B1670"></script>
    <script src="../_static/runestone.ecc6dff5cad8b815.bundle.js?v=AE959292"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://media.ethicalads.io/media/client/ethicalads.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="14.3. Binary Search Tree iterators" href="bst-iterator.html" />
    <link rel="prev" title="14.1. Tree ADT concepts" href="trees.html" />


<link rel="shortcut icon" href="/cisc187-reader/static/favicon.ico" type="image/ico" />



<link rel="canonical" href="https://{{canonical_host}}{{new_server_prefix}}/books/published/{{base_course}}/{{pagepath}}" />


<script>
  eBookConfig = {};
  
    eBookConfig.useRunestoneServices = false;
    eBookConfig.host = 'https://daveparillo.github.io/cisc187-reader/' || 'http://127.0.0.1:8000';
    eBookConfig.app = eBookConfig.host+'/cisc187-reader';
    eBookConfig.course = 'cisc187-reader';
    eBookConfig.basecourse = 'cisc187-reader';
    eBookConfig.isLoggedIn = false;
    eBookConfig.enableCompareMe = eBookConfig.useRunestoneServices;
    eBookConfig.new_server_prefix = '';
  
  eBookConfig.ajaxURL = eBookConfig.app+'/ajax/';
  eBookConfig.logLevel = 0;
  eBookConfig.loginRequired = false;
  eBookConfig.build_info = "unknown";
  eBookConfig.python3 = true;
  eBookConfig.acDefaultLanguage = 'cpp' ? 'cpp' : 'python'
  eBookConfig.runestone_version = '6.6.2';
  eBookConfig.jobehost = 'https://delicate-frost-8843.fly.dev';
  eBookConfig.proxyuri_runs = '/jobe/index.php/restapi/runs/';
  eBookConfig.proxyuri_files = '/jobe/index.php/restapi/files/';
  eBookConfig.enable_chatcodes = false ? false : false;
  eBookConfig.enableScratchAC = true;

</script>

<!-- Ad Serving Headers Only serve ads to Anonymous Users -->



  </head><body>


<!-- Begin navbar -->
<div id="navbar" class="navbar navbar-default navbar-fixed-top" role="navigation">

  <div class="container">

    <div class="navbar-header">
      <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
      <button type='button' class='navbar-toggle' data-toggle="collapse" data-target=".navbar-ex1-collapse" aria-label="navbar toggle">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <div>
        
        
          <div class="brand-logo"><img src="../_static/img/RAIcon.png" alt=""></div>
        
        <a class="navbar-brand" href="../index.html" aria-label="index-page">
          
          cisc187-reader
        </a>
      </div>
    </div>



    <div class="navbar-collapse collapse navbar-ex1-collapse">
      <ul class="nav navbar-nav navbar-right" >

        <li class="divider-vertical"></li>

        <!-- social media dropdown -->
        <!-- end social media dropdown -->

        <li class="divider-vertical"></li>
        <!-- search dropdown -->
        <li class="dropdown">
          <a class="dropdown-toggle" href="#" data-toggle="dropdown">
            <i class="glyphicon glyphicon-search" style='opacity:0.9;'><span class="visuallyhidden" aria-label="Search">Search</span></i>
          </a>
          <ul class='dropdown-menu'>
            
                <li><a href='../index.html' aria-label="index-page">Table of Contents</a></li>
            
            <li><a href='../genindex.html'>Book Index</a></li>
            <li class="divider"></li>
            <li style="width: 240px;">
              <form class="navbar-search" style="margin:10px;" action="../search.html" method="get">
                <div class="input-group">
                  <input type="text" class="form-control" name="q" placeholder="Search this book" />
                  <span class="input-group-btn">
                    <button class="btn btn-primary" style="margin:0;" type="submit">
                      <i class="glyphicon glyphicon-search"></i>
                    </button>
                  </span>
                </div><!-- /input-group -->
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
            </li>
          </ul>
        </li>
        <!-- end search dropdown -->

        <li class="divider-vertical"></li>

        
        <li class="divider-vertical"></li>
        <!-- <li id="scratch_ac_link"><a href="javascript:ACFactory.toggleScratchActivecode()">Scratch ActiveCode</a></li> -->

        <!-- <li class="dropdown">             -->
          <li id="scratch_ac_link" class="dropdown"><a href="javascript:runestoneComponents.popupScratchAC()">
              <i class="glyphicon glyphicon-pencil" style="opacity:0.9;"><span class="visuallyhidden" aria-label="Scratch Activecode" >Scratch Activecode</span></i></a></li>
        <!-- </li> -->

        <li class="divider-vertical"></li>

        
      </ul>

      <ul class="nav navbar-nav">
        <li class="divider-vertical"></li>
        
          
          <li class="divider-vertical"></li>
        
        <!-- 
          
  <li id="relations-prev" title="Previous Chapter - <span class="section-number">14.1. </span>Tree ADT concepts" data-toggle="tooltip">
    <a href="trees.html" >
      <i class='glyphicon glyphicon-backward' style='opacity:0.9;'></i>
    </a>
  </li>
  
  <li id="relations-next" title='Next Chapter - <span class="section-number">14.3. </span>Binary Search Tree iterators' data-toggle="tooltip" >              
    <a href="bst-iterator.html" >
        <i class='glyphicon glyphicon-forward' style='opacity:0.9;'></i>
    </a>
  </li>
  <li class="divider-vertical"></li>

<script>
  opts = {'placement':'bottom',
          'selector': '',
          'delay': { show: 100, hide: 50}
         };

  window.addEventListener('load', (event) => {
    $('#relations-prev').tooltip(opts);
    $('#relations-next').tooltip(opts);
  });
</script>
        -->
        
          <li></li>
        
      </ul>
      </div> <!-- navbar-collapse -->
    </div> <!-- navbar -->
  </div> <!-- container -->


<div class="container" id="continue-reading"></div>

<div class="container" id="main-content" role="main">

<!-- Ad Serving for Runestone Campaign -->


  
  <section id="binary-search-trees">
<span id="index-0"></span><h1><span class="section-number">14.2. </span>Binary Search Trees<a class="headerlink" href="#binary-search-trees" title="Permalink to this heading">¶</a></h1>
<p>A binary tree T is a binary search tree if, for each node <code class="docutils literal notranslate"><span class="pre">n</span></code>
with sub-trees <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code>,</p>
<ul class="simple">
<li><p>The value in <code class="docutils literal notranslate"><span class="pre">n</span></code> is <strong>greater than</strong> the values in every node in <code class="docutils literal notranslate"><span class="pre">left</span></code>.</p></li>
<li><p>The value in <code class="docutils literal notranslate"><span class="pre">n</span></code> is <strong>less than</strong> the values in every node in <code class="docutils literal notranslate"><span class="pre">right</span></code>.</p></li>
<li><p>Both <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> are binary search trees.</p></li>
</ul>
<p>These assertions define the <strong>binary tree property</strong>.</p>
<div align="center" class="align-center"><div class="graphviz"><img src="../_images/graphviz-43a8b9558b3b234c87044fe1045c0b161ea623c9.png" alt="a binary search tree" class="graphviz" /></div>
</div>

    <div data-component="reveal" class="runestone " id="reveal-bst-1"   data-showtitle="Is this a BST?" data-hidetitle="Hide"  style="visibility: hidden;">
    <p>Yes.</p>
<p>Each node is greater than or equal to all of its left descendants,
and is less than or equal than all of its right descendants.</p>

    </div>
    <section id="the-binary-search-tree-adt">
<h2><span class="section-number">14.2.1. </span>The Binary Search Tree ADT<a class="headerlink" href="#the-binary-search-tree-adt" title="Permalink to this heading">¶</a></h2>
<p>Structurally, a BST contains pointers to it’s left and right children.
As discussed in <a class="reference internal" href="../recursion/index.html"><span class="doc">Recursion</span></a>,
a binary tree can be implemented simply as a recursive data structure.
A binary search tree can also be implemented recursively.</p>
<p>It is a bit simpler to define the tree nodes as a separate type.
Whether you design this class as a completely independent
class, like this one,
or implement it as a nested (inner) class, is largely a matter of
choice.</p>
<p>Since a <code class="docutils literal notranslate"><span class="pre">tree_node</span></code> is a data structure that can exist independently
of a tree that enforces the binary search tree property,
it makes sense in this case to define it as a completely separate
struct with no invariants.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">tree_node</span></code> encapsulates the general characteristics
common to all binary trees:</p>
<ul class="simple">
<li><p>A variable to store the node value</p></li>
<li><p>Pointers to the left and right child nodes,
which might themselves be sub-trees.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">mesa</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">tree</span><span class="w"> </span><span class="p">{</span>

<span class="w">   </span><span class="c1">// a binary tree node</span>
<span class="w">   </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">     </span><span class="k">struct</span><span class="w"> </span><span class="nc">tree_node</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">       </span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">left</span><span class="p">;</span>
<span class="w">       </span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">       </span><span class="n">tree_node</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">{},</span>
<span class="w">           </span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span>
<span class="w">           </span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">         </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">{</span><span class="n">value</span><span class="p">}</span>
<span class="w">       </span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p">{</span><span class="n">left</span><span class="p">}</span>
<span class="w">       </span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">{</span><span class="n">right</span><span class="p">}</span>
<span class="w">       </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="w">     </span><span class="p">};</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// end namespace tree</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// end namespace mesa</span>
</pre></div>
</div>
<p>In other words, a <code class="docutils literal notranslate"><span class="pre">tree_node</span></code> is a general purpose
binary tree data structure and has no knowledge of
any binary search tree properties or behavior.</p>
<div class="admonition-binary-search-tree-traversal admonition">
<p class="admonition-title">Binary Search Tree Traversal</p>
<p>One benefit of a binary search tree is that when the
nodes are visited using infix traversal,
the data is sorted ascending.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// write a tree to an output stream, infix</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">os</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">mesa</span><span class="o">::</span><span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">node</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">os</span><span class="p">;</span>
<span class="w">     </span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
<span class="w">     </span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">;</span>
<span class="w">     </span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">os</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
</pre></div>
</div>
<p>Notice we stream <code class="docutils literal notranslate"><span class="pre">tree_node</span></code> objects here,
not <code class="docutils literal notranslate"><span class="pre">bstree</span></code> objects.</p>
</div>
<p>Much like our earlier tree objects, all of the functions used to manipulate
a <code class="docutils literal notranslate"><span class="pre">tree_node</span></code> will be free functions.
To avoid collision with other similarly named functions,
all the functions will be defined in the <code class="docutils literal notranslate"><span class="pre">mesa::tree</span></code> namespace.</p>
<p>The binary search tree is built up from individual <code class="docutils literal notranslate"><span class="pre">tree_node</span></code> objects.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">bstree</span></code> class has 1 private member variable: a pointer
to a <code class="docutils literal notranslate"><span class="pre">tree_node</span></code>.
The basic skeleton of the class should look familiar:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">mesa</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">// a binary search tree</span>
<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">bstree</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="k">typedef</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">value_type</span><span class="p">;</span>

<span class="w">        </span><span class="n">bstree</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// convert a value into a tree</span>
<span class="w">        </span><span class="k">explicit</span>
<span class="w">          </span><span class="n">bstree</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="w">          </span><span class="o">:</span><span class="w"> </span><span class="n">root</span><span class="p">{</span><span class="k">new</span><span class="w"> </span><span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span><span class="n">value</span><span class="p">}}</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// copy construct and assign</span>
<span class="w">        </span><span class="n">bstree</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">bstree</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="w">        </span><span class="n">bstree</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">bstree</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// move construct and assign</span>
<span class="w">        </span><span class="n">bstree</span><span class="p">(</span><span class="n">bstree</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="w">        </span><span class="n">bstree</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">bstree</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="w">        </span><span class="k">constexpr</span>
<span class="w">          </span><span class="kt">bool</span><span class="w"> </span><span class="nf">empty</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">      </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="w">    </span><span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// end namespace mesa</span>
</pre></div>
</div>
<p>Our primary focus for the rest of this section is on the functions
that define the key operations associated with a BST:</p>
<ul class="simple">
<li><p>contains and find</p></li>
<li><p>insert and erase</p></li>
</ul>
</section>
<section id="searching-binary-trees">
<h2><span class="section-number">14.2.2. </span>Searching binary trees<a class="headerlink" href="#searching-binary-trees" title="Permalink to this heading">¶</a></h2>
<p>Efficient search of a binary tree uses the same algorithm
you would use when playing the ‘number guessing’ game.
If asked to guess a random number between <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">100</span></code> in the
fewest possible tries, with a hint <code class="docutils literal notranslate"><span class="pre">higher</span></code> or <code class="docutils literal notranslate"><span class="pre">lower</span></code>
after each attempt, few people would start at <code class="docutils literal notranslate"><span class="pre">1</span></code>,
then guess <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code>, and so on until they guessed correctly.
Most people would start with <code class="docutils literal notranslate"><span class="pre">50</span></code> and continue to split the
remaining unknown partition in half until they found the correct number.</p>
<p>The strategy most people apply to this problem intuitively is known
as the <a class="reference internal" href="../glossary.html#term-binary-search"><span class="xref std std-term">binary search</span></a> algorithm.
This algorithm is easily applied to binary search trees.</p>
<div id='contains_tab' data-component="tabbedStuff"  class='alert alert-warning '><div data-component="tab" data-tabname="contains" >
<p>We always search a binary search tree by comparing the value we’re
searching for to the ‘current’ node value.
If the target value is smaller,
then we search the left subtree.
If the target value is larger, then we search the right subtree.</p>
<p>If it is neither of these things, then we found the value.</p>
<p>This function is implemented as a <code class="docutils literal notranslate"><span class="pre">mesa::tree</span></code> free function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">contains</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">query_value</span><span class="p">,</span><span class="w"> </span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">query_value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">contains</span><span class="p">(</span><span class="n">query_value</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">query_value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">contains</span><span class="p">(</span><span class="n">query_value</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
    </div>

</section>
<section id="inserting-into-binary-trees">
<h2><span class="section-number">14.2.3. </span>Inserting into binary trees<a class="headerlink" href="#inserting-into-binary-trees" title="Permalink to this heading">¶</a></h2>
<p>Inserting into a binary tree means adding a new node in the tree
such that the binary tree property remains intact.</p>
<div id='insert_tab' data-component="tabbedStuff"  class='alert alert-warning '><div data-component="tab" data-tabname="insert" >
<p>The insert process begins with a search for a place to insert a new value.
But how do we find the place at which to insert that new node?
Ask “where would we go if we were searching for this data in the tree?”
This process is identical to the search used for the contains function.</p>
<p>This function is implemented as a <code class="docutils literal notranslate"><span class="pre">bstree</span></code> member function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span>
<span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&amp;</span><span class="w"> </span><span class="n">node</span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// add a new leaf</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">tree</span><span class="o">::</span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">node</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="c1">// else the value already exists in the tree</span>
<span class="w">   </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">node</span><span class="p">;</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>There are a few important things to notice about this function.</p>
<p>The insert function receives the current node pointer as
a reference to a pointer,
It can change the value of the pointer provided.
It does this specifically when our traversal brings us to a null pointer.
A <a class="reference internal" href="../glossary.html#term-leaf-node"><span class="xref std std-term">leaf node</span></a> is place where we can insert a new
tree node while still adhering to the binary search tree property.</p>
<p>Overwriting an existing value is a design choice.
We could have chosen to do nothing and simply return the node.</p>
</div>
    </div>

<div class="admonition-try-this admonition">
<p class="admonition-title">Try This!</p>
<p>Walk through this algorithm yourself with different sets of values.</p>
<p>Experiment with inserting nodes into binary search trees.
Take particular note of what happens if you insert data in
ascending or descending order, as opposed to inserting unordered data.</p>
</div>
</section>
<section id="erasing-binary-tree-nodes">
<h2><span class="section-number">14.2.4. </span>Erasing binary tree nodes<a class="headerlink" href="#erasing-binary-tree-nodes" title="Permalink to this heading">¶</a></h2>
<p>The erase process also begins with a search for the place to erase.
This process is identical to the search used for contains and insert.</p>
<p>The tricky part of removing a value from a binary search tree
is what to do when we actually find the value we want to delete.
We can’t just delete the tree node.
Consider the following tree.</p>
<div align="center" class="align-center"><div class="graphviz"><img src="../_images/graphviz-43a8b9558b3b234c87044fe1045c0b161ea623c9.png" alt="a binary search tree" class="graphviz" /></div>
</div>
<p>If we remove values <code class="docutils literal notranslate"><span class="pre">10</span></code>, <code class="docutils literal notranslate"><span class="pre">40</span></code>, or <code class="docutils literal notranslate"><span class="pre">60</span></code>
by simply deleting the tree node, that might work.
However, deleting any other node would break the links between tree nodes.</p>
<p>We have 3 cases to consider:</p>
<ul class="simple">
<li><p>Removing a leaf</p></li>
<li><p>Removing a node that has only one child</p>
<ul>
<li><p>only a left child</p></li>
<li><p>only a right child</p></li>
</ul>
</li>
<li><p>Removing a node that has two children</p></li>
</ul>
<section id="removing-a-leaf-node">
<h3><span class="section-number">14.2.4.1. </span>Removing a leaf node<a class="headerlink" href="#removing-a-leaf-node" title="Permalink to this heading">¶</a></h3>
<p>It’s easy to see that we can always remove any leaf in a
binary search tree without affecting anything else.
That is, if we remove any leaf from a binary search tree,
we still have a valid binary search tree.
There is nothing else to do.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">node</span></code> points to a leaf that contains the data we want to remove
we replace the address in <code class="docutils literal notranslate"><span class="pre">node</span></code> by <code class="docutils literal notranslate"><span class="pre">node-&gt;right</span></code>.
If <code class="docutils literal notranslate"><span class="pre">node</span></code> is pointing to a leaf, then <code class="docutils literal notranslate"><span class="pre">node-&gt;right</span></code> is null
and we write a nullptr into the parent node,
replacing whichever of its two children pointers was used to get to <code class="docutils literal notranslate"><span class="pre">node</span></code>.</p>
<p>In other words, leaf nodes are replaced with the null pointer.</p>
</section>
<section id="removing-a-non-leaf-node-with-a-null-child">
<h3><span class="section-number">14.2.4.2. </span>Removing a non-leaf node with a null child<a class="headerlink" href="#removing-a-non-leaf-node-with-a-null-child" title="Permalink to this heading">¶</a></h3>
<p>Removing nodes from the interior of the tree is a bit more work
as we need to maintain links between nodes.</p>
<p>Given the same tree we have been working with so far:</p>
<div align="center" class="align-center"><div class="graphviz"><img src="../_images/graphviz-43a8b9558b3b234c87044fe1045c0b161ea623c9.png" alt="a binary search tree" class="graphviz" /></div>
</div>
<p><strong>Question</strong>
Suppose we wanted to remove the <code class="docutils literal notranslate"><span class="pre">20</span></code> or the <code class="docutils literal notranslate"><span class="pre">70</span></code> from this tree.
What would we have to do so that the
remaining nodes would still be a valid BST?</p>

    <div data-component="reveal" class="runestone " id="reveal-bst-2"   data-showtitle="Show" data-hidetitle="Hide"  style="visibility: hidden;">
    <p>There is one pointer to the node being deleted,
and one pointer from that node to its only child.</p>
<p>So this is actually a bit like deleting a node from
the middle of a linked list.</p>
<p>All we need to do is to update the pointer from the
parent <code class="docutils literal notranslate"><span class="pre">30</span></code> node.
That pointer should point to the child of the node we are going to remove.</p>
<div align="center" class="align-center"><div class="graphviz"><img src="../_images/graphviz-3add7b7ca9b37a48df5cc97ffeaf46d0439d9360.png" alt="a binary search tree" class="graphviz" /></div>
</div>

    </div>
    <p>Verify that if we remove either <code class="docutils literal notranslate"><span class="pre">20</span></code> or <code class="docutils literal notranslate"><span class="pre">70</span></code>,
the resulting tree is still a valid binary search tree.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><div class="graphviz"><img src="../_images/graphviz-c4640aac37e5e28e9cac60c38413899ee8accb50.png" alt="a binary search tree with 20 removed" class="graphviz" /></div>
</td>
<td><div class="graphviz"><img src="../_images/graphviz-042a3baf0670d25a3bf0ca98332d6e36731cda1f.png" alt="a binary search tree" class="graphviz" /></div>
</td>
</tr>
</tbody>
</table>
<p>The code we used to remove a leaf also works when there is only one child.</p>
<p>If we reach this code, we know there is at most
one non-null child.
In the previous case of a leaf node,
both children are null,
but the same code works for one child also.</p>
<p>If the left child is not null,
then reassign the left child to the current node,
otherwise assign the right child.</p>
</section>
<section id="removing-a-non-leaf-node-with-a-two-children">
<h3><span class="section-number">14.2.4.3. </span>Removing a non-leaf node with a two children<a class="headerlink" href="#removing-a-non-leaf-node-with-a-two-children" title="Permalink to this heading">¶</a></h3>
<p>Suppose we wanted to remove the <code class="docutils literal notranslate"><span class="pre">50</span></code> or the <code class="docutils literal notranslate"><span class="pre">30</span></code> from this tree.
What must we do so that the remaining nodes would still be a valid BST?</p>
<p>This is a hard case.
If we remove either the <code class="docutils literal notranslate"><span class="pre">50</span></code> or <code class="docutils literal notranslate"><span class="pre">30</span></code> nodes,
then we break the tree into pieces,
with no obvious place to put the now-detached subtrees.</p>
<div align="center" class="align-center"><div class="graphviz"><img src="../_images/graphviz-43a8b9558b3b234c87044fe1045c0b161ea623c9.png" alt="a binary search tree" class="graphviz" /></div>
</div>
<p>There is an efficient solution to this problem.
Instead of deleting the node when we find it,
is there some other data value that we could put into that node that would
preserve the BST property?</p>
<p>There are, in fact,
two values that we could safely put in there:</p>
<ul class="simple">
<li><p>the smallest value from the right subtree</p></li>
<li><p>the largest value from the left subtree</p></li>
</ul>
<p>We can find the <strong>largest</strong> value on the <strong>left</strong> by</p>
<ul class="simple">
<li><p>taking one step to the left</p></li>
<li><p>then running as far down to the right as we can go</p></li>
</ul>
<p>We can find the <strong>smallest</strong> value on the <strong>right</strong> by</p>
<ul class="simple">
<li><p>taking one step to the right</p></li>
<li><p>then running as far down to the left as we can go</p></li>
</ul>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><div align="center" class="align-center"><div class="graphviz"><img src="../_images/graphviz-6305a0cbaf4dede2170accd89eeb6810eb43e722.png" alt="a binary search tree" class="graphviz" /></div>
</div>
</td>
<td><div align="center" class="align-center"><div class="graphviz"><img src="../_images/graphviz-57eadd55260723e4c7ea4ca8d52ea7088bef678b.png" alt="a binary search tree" class="graphviz" /></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>At this point, we haven’t deleted or created any nodes.
We simply copy a value from one node to another.
Now we have two nodes in our tree with the same value,
either <code class="docutils literal notranslate"><span class="pre">20</span></code> or <code class="docutils literal notranslate"><span class="pre">40</span></code>,
depending on which approach we used.</p>
<p>We still need to delete the smallest right node
or the largest left node.
What makes this last step simple is that it falls under our
previous case: it is by definition either a leaf,
or has at most one child.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><div class="graphviz"><img src="../_images/graphviz-afe0f84d9823a9e677a55046fcc57af2cb71e9bd.png" alt="a binary search tree" class="graphviz" /></div>
</td>
<td><div class="graphviz"><img src="../_images/graphviz-34523ecdb997ed9d6f0e79db5271270a9c97a368.png" alt="a binary search tree" class="graphviz" /></div>
</td>
</tr>
</tbody>
</table>
<div id='erase_tab' data-component="tabbedStuff"  class='alert alert-warning '><div data-component="tab" data-tabname="erase" >
<p>Putting it all together.</p>
<p>This function is implemented as a <code class="docutils literal notranslate"><span class="pre">mesa::tree</span></code> free function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="linenos"> 2</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">erase</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&amp;</span><span class="w"> </span><span class="n">node</span><span class="p">)</span>
<span class="linenos"> 3</span><span class="w">  </span><span class="p">{</span>
<span class="linenos"> 4</span><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>
<span class="linenos"> 5</span>
<span class="hll"><span class="linenos"> 6</span><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span class="hll"><span class="linenos"> 7</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">erase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span><span class="hll"><span class="linenos"> 8</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span class="hll"><span class="linenos"> 9</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">erase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span><span class="linenos">10</span>
<span class="linenos">11</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">12</span><span class="w">      </span><span class="c1">// two children</span>
<span class="linenos">13</span><span class="w">      </span><span class="c1">// replace node with smallest value from right subtree</span>
<span class="linenos">14</span><span class="w">      </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min_element</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
<span class="linenos">15</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">erase</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="linenos">16</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">17</span><span class="w">      </span><span class="c1">// remove a leaf node or node w/ 1 subtree</span>
<span class="linenos">18</span><span class="w">      </span><span class="n">tree_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">trash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span>
<span class="linenos">19</span><span class="w">      </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
<span class="linenos">20</span><span class="w">      </span><span class="k">delete</span><span class="w"> </span><span class="n">trash</span><span class="p">;</span>
<span class="linenos">21</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">22</span><span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Lines 6-9 handle the search we discussed initially.
Here we recursive search for our target value to remove.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span></code> block handles the case with 2 children.
We find the smallest node in the right subtree
and assign it’s value to the current node.
Then we erase this value from the right subtree
of the current node.</p>
<p>The final <code class="docutils literal notranslate"><span class="pre">else</span></code> block handles the leaf and the one child cases.
This is the only case where a node is actually removed from the tree.
This block will also untilately get called when the
case handling two child nodes needs to delete the
smallest value from the right subtree.</p>
</div>
    </div>

<hr class="docutils" />
<div class="admonition-more-to-explore admonition">
<p class="admonition-title">More to Explore</p>
<ul class="simple">
<li><p>The content on this page was adapted from
<a class="reference external" href="https://www.cs.odu.edu/~zeil/cs361/latest/Public/bst/index.html">Binary Search Trees</a>,
by Steven J. Zeil for his data structures course CS361.</p></li>
<li><p><a class="reference external" href="http://www.mycodeschool.com">MyCodeSchool</a> video:
<a class="reference external" href="https://www.youtube.com/watch?v=pYT9F8_LFTM&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=27">Data structures: binary search trees</a></p></li>
<li><p>Wikipedia</p>
<ul>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Binary_search_tree">binary search tree</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="http://btv.melezinek.cz">Binary tree visualizer</a></p></li>
</ul>
</div>
</section>
</section>
</section>


  

  <div id="scprogresscontainer">
    You have attempted <span id="scprogresstotal"></span> of <span id="scprogressposs"></span> activities on this page <div id="subchapterprogress" aria-label="Page progress"></div>
  </div>

  <ul role="navigation" class="nextprev-list nextprev-list" aria-label="Change page">
<li id="relations-prev" class="navLink" title='Previous Section - 14.1. Tree ADT concepts' data-toggle="tooltip">
  <a href="trees.html" aria-label="Previous - 14.1. Tree ADT concepts">
    <i class='prevNav glyphicon glyphicon-chevron-left'  style="top:50%; transform:translateY(-50%)translateX(-50%); left: 50%; color:black;"></i>
  </a>
</li>

  <li id="relations-next" class="navLink" title='Next Section - 14.3. Binary Search Tree iterators' data-toggle="tooltip" >
    <a href="bst-iterator.html" aria-label="Next - 14.3. Binary Search Tree iterators">
      <i id="relationsNextIcon" class='nextNav glyphicon glyphicon-chevron-right' style="top:50%; transform:translateY(-50%)translateX(-50%); left: 50%; color:black; "></i>
    </a>
  </li>
</ul>

<script>
window.addEventListener('load', (event) => {
  $('#relations-prev').tooltip({'placement': 'right', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement': 'left', 'delay': { show: 100, hide: 50}});
});
</script>

</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      
      | <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2024 Dave Parillo.
      Created using <a href="http://runestoneinteractive.org/">Runestone</a> 6.6.2.
    </p>
  </div>
</footer>




<script>
  window.addEventListener('load', (event) => {
    runestoneComponents.getSwitch();
  });
</script>


  </body>
</html>