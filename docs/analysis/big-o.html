<!-- ****************************************
     |docname| - main template for this theme
     **************************************** -->
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Asymptotic Analysis and Upper Bounds &#8212; CISC 187 Course Reader Overview</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/accessibility.css?v=50109A2C" />
    <link rel="stylesheet" type="text/css" href="../_static/matrixeq.css?v=58BC228F" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/637.0fa6cababf056764.css?v=F9484CEF" />
    <link rel="stylesheet" type="text/css" href="../_static/runestone.3eb60bc006ae9a54.css?v=3A5A250C" />



    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/animationbase.js?v=A043C3A7"></script>
    <script src="../_static/matrixeq.js?v=D64CFA5A"></script>
    <script src="../_static/runtime.66b619f51b746382.bundle.js?v=C3F69EE5"></script>
    <script src="../_static/637.d54be67956c5c660.bundle.js?v=915B1670"></script>
    <script src="../_static/runestone.ecc6dff5cad8b815.bundle.js?v=AE959292"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://media.ethicalads.io/media/client/ethicalads.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Lower Bounds" href="big-theta.html" />
    <link rel="prev" title="Best, worst, and average cases" href="cases.html" />


<link rel="shortcut icon" href="/cisc187-reader/static/favicon.ico" type="image/ico" />



<link rel="canonical" href="https://{{canonical_host}}{{new_server_prefix}}/books/published/{{base_course}}/{{pagepath}}" />


<script>
  eBookConfig = {};
  
    eBookConfig.useRunestoneServices = false;
    eBookConfig.host = 'https://daveparillo.github.io/cisc187-reader/' || 'http://127.0.0.1:8000';
    eBookConfig.app = eBookConfig.host+'/cisc187-reader';
    eBookConfig.course = 'cisc187-reader';
    eBookConfig.basecourse = 'cisc187-reader';
    eBookConfig.isLoggedIn = false;
    eBookConfig.enableCompareMe = eBookConfig.useRunestoneServices;
    eBookConfig.new_server_prefix = '';
  
  eBookConfig.ajaxURL = eBookConfig.app+'/ajax/';
  eBookConfig.logLevel = 0;
  eBookConfig.loginRequired = false;
  eBookConfig.build_info = "unknown";
  eBookConfig.python3 = true;
  eBookConfig.acDefaultLanguage = 'cpp' ? 'cpp' : 'python'
  eBookConfig.runestone_version = '6.6.2';
  eBookConfig.jobehost = 'https://delicate-frost-8843.fly.dev';
  eBookConfig.proxyuri_runs = '/jobe/index.php/restapi/runs/';
  eBookConfig.proxyuri_files = '/jobe/index.php/restapi/files/';
  eBookConfig.enable_chatcodes = false ? false : false;
  eBookConfig.enableScratchAC = true;

</script>

<!-- Ad Serving Headers Only serve ads to Anonymous Users -->



  </head><body>


<!-- Begin navbar -->
<div id="navbar" class="navbar navbar-default navbar-fixed-top" role="navigation">

  <div class="container">

    <div class="navbar-header">
      <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
      <button type='button' class='navbar-toggle' data-toggle="collapse" data-target=".navbar-ex1-collapse" aria-label="navbar toggle">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <div>
        
        
          <div class="brand-logo"><img src="../_static/img/RAIcon.png" alt=""></div>
        
        <a class="navbar-brand" href="../index.html" aria-label="index-page">
          
          cisc187-reader
        </a>
      </div>
    </div>



    <div class="navbar-collapse collapse navbar-ex1-collapse">
      <ul class="nav navbar-nav navbar-right" >

        <li class="divider-vertical"></li>

        <!-- social media dropdown -->
        <!-- end social media dropdown -->

        <li class="divider-vertical"></li>
        <!-- search dropdown -->
        <li class="dropdown">
          <a class="dropdown-toggle" href="#" data-toggle="dropdown">
            <i class="glyphicon glyphicon-search" style='opacity:0.9;'><span class="visuallyhidden" aria-label="Search">Search</span></i>
          </a>
          <ul class='dropdown-menu'>
            
                <li><a href='../index.html' aria-label="index-page">Table of Contents</a></li>
            
            <li><a href='../genindex.html'>Book Index</a></li>
            <li class="divider"></li>
            <li style="width: 240px;">
              <form class="navbar-search" style="margin:10px;" action="../search.html" method="get">
                <div class="input-group">
                  <input type="text" class="form-control" name="q" placeholder="Search this book" />
                  <span class="input-group-btn">
                    <button class="btn btn-primary" style="margin:0;" type="submit">
                      <i class="glyphicon glyphicon-search"></i>
                    </button>
                  </span>
                </div><!-- /input-group -->
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
            </li>
          </ul>
        </li>
        <!-- end search dropdown -->

        <li class="divider-vertical"></li>

        
        <li class="divider-vertical"></li>
        <!-- <li id="scratch_ac_link"><a href="javascript:ACFactory.toggleScratchActivecode()">Scratch ActiveCode</a></li> -->

        <!-- <li class="dropdown">             -->
          <li id="scratch_ac_link" class="dropdown"><a href="javascript:runestoneComponents.popupScratchAC()">
              <i class="glyphicon glyphicon-pencil" style="opacity:0.9;"><span class="visuallyhidden" aria-label="Scratch Activecode" >Scratch Activecode</span></i></a></li>
        <!-- </li> -->

        <li class="divider-vertical"></li>

        
      </ul>

      <ul class="nav navbar-nav">
        <li class="divider-vertical"></li>
        
          
          <li class="divider-vertical"></li>
        
        <!-- 
          
  <li id="relations-prev" title="Previous Chapter - Best, worst, and average cases" data-toggle="tooltip">
    <a href="cases.html" >
      <i class='glyphicon glyphicon-backward' style='opacity:0.9;'></i>
    </a>
  </li>
  
  <li id="relations-next" title='Next Chapter - Lower Bounds' data-toggle="tooltip" >              
    <a href="big-theta.html" >
        <i class='glyphicon glyphicon-forward' style='opacity:0.9;'></i>
    </a>
  </li>
  <li class="divider-vertical"></li>

<script>
  opts = {'placement':'bottom',
          'selector': '',
          'delay': { show: 100, hide: 50}
         };

  window.addEventListener('load', (event) => {
    $('#relations-prev').tooltip(opts);
    $('#relations-next').tooltip(opts);
  });
</script>
        -->
        
          <li></li>
        
      </ul>
      </div> <!-- navbar-collapse -->
    </div> <!-- navbar -->
  </div> <!-- container -->


<div class="container" id="continue-reading"></div>

<div class="container" id="main-content" role="main">

<!-- Ad Serving for Runestone Campaign -->


  
  <section id="asymptotic-analysis-and-upper-bounds">
<span id="analysis-big-o"></span><span id="index-0"></span><h1>Asymptotic Analysis and Upper Bounds<a class="headerlink" href="#asymptotic-analysis-and-upper-bounds" title="Permalink to this heading">¶</a></h1>
<p>Recall our growth rates from a little while ago.</p>
<figure class="align-default">
<img alt="../_images/big-o-1.png" class="plot-directive" src="../_images/big-o-1.png" />
</figure>
<p>Despite the larger constant for the curve labeled <span class="math notranslate nohighlight">\(10 n\)</span> in
the figure above, <span class="math notranslate nohighlight">\(2 n^2\)</span> crosses it at the
relatively small value of <span class="math notranslate nohighlight">\(n = 5\)</span>.
What if we double the value of the constant in front of the linear
equation?
As shown in the graph, <span class="math notranslate nohighlight">\(20 n\)</span> is surpassed by <span class="math notranslate nohighlight">\(2 n^2\)</span>
once <span class="math notranslate nohighlight">\(n = 10\)</span>.
The additional factor of two for the linear <a class="reference internal" href="../glossary.html#term-growth-rate"><span class="xref std std-term">growth rate</span></a> does
not much matter.
It only doubles the <span class="math notranslate nohighlight">\(x\)</span>-coordinate for the intersection point.
In general, changes to a constant factor in either equation only
shift <em>where</em> the two curves cross, not <em>whether</em>
the two curves cross.</p>
<p>When you buy a faster computer or a faster compiler,
the new problem size that can be run in a given amount of time for a
given growth rate is
larger by the same factor, regardless of the constant on the
running-time equation.
The time curves for two algorithms with different growth rates
still cross, regardless of their running-time equation constants.
For these reasons, we usually ignore the constants when we want an
estimate of the growth rate for the running time or other resource
requirements of an algorithm.
This simplifies the analysis and keeps us thinking about the most
important aspect: the growth rate.
This is called <a class="reference internal" href="../glossary.html#term-asymptotic-algorithm-analysis"><span class="xref std std-term">asymptotic algorithm analysis</span></a>.
To be precise, asymptotic analysis refers to the study of an
algorithm as the input size “gets big” or reaches
a limit (in the calculus sense).
However, it has proved to be so useful to ignore all constant factors
that asymptotic analysis is used for most algorithm comparisons.</p>
<section id="big-o-notation">
<h2>Big-O Notation<a class="headerlink" href="#big-o-notation" title="Permalink to this heading">¶</a></h2>
<p>When trying to characterize an algorithm’s efficiency in terms of
execution time, independent of any particular program or computer, it is
important to quantify the number of operations or steps that the
algorithm will require. If each of these steps is considered to be a
basic unit of computation, then the execution time for an algorithm can
be expressed as the number of steps required to solve the problem.
Deciding on an appropriate basic unit of computation can be a
complicated problem and will depend on how the algorithm is implemented.</p>
<p>Consider the problem of accumulating a sum.
The idea of a simple loop to add values should be familiar.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>accumulate1<span class="o">(</span>int:<span class="w"> </span>N<span class="o">)</span>
<span class="w">   </span>sum<span class="w"> </span>←<span class="w"> </span><span class="m">0</span>
<span class="w">   </span>count<span class="w">  </span>←<span class="w"> </span>N
<span class="w">   </span><span class="k">while</span><span class="w"> </span>count<span class="w"> </span>&gt;<span class="w"> </span><span class="m">0</span>
<span class="w">      </span>sum<span class="w"> </span>←<span class="w"> </span>sum<span class="w"> </span>+<span class="w"> </span>count
<span class="w">      </span>count<span class="w"> </span>←<span class="w"> </span>count<span class="w"> </span>-<span class="w"> </span><span class="m">1</span>
<span class="w">   </span><span class="k">done</span><span class="w"> </span><span class="k">while</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span>sum
<span class="k">done</span><span class="w"> </span>accumulate
</pre></div>
</div>
<p>Compare the previous algorithm to this one:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>accumulate2<span class="o">(</span>int:<span class="w"> </span>N<span class="o">)</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span>N<span class="w"> </span>≡<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="k">return</span><span class="w"> </span>N
<span class="w">   </span><span class="k">return</span><span class="w"> </span>N<span class="w"> </span>+<span class="w"> </span>accumulate<span class="o">(</span>N-1<span class="o">)</span>
<span class="k">done</span><span class="w"> </span>accumulate
</pre></div>
</div>
<p>Are both implementations valid?</p>
<p>Is one more efficient than the other?</p>
<p>How do we characterize functions that appear to be different
and compare them using a consistent yardstick?
Asymptotic analysis to the rescue.</p>
<p>A good basic unit of computation for comparing the summation algorithms
shown earlier might be to count the number of assignment statements
performed to compute the sum. In the function <code class="docutils literal notranslate"><span class="pre">accumulate1</span></code>, the number of
assignment statements is 2 — assigning <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">sum</span></code> and
assigning <code class="docutils literal notranslate"><span class="pre">N</span></code> to <code class="docutils literal notranslate"><span class="pre">count</span></code>,
plus the value of <em>n</em> (the number of times we perform
<span class="math notranslate nohighlight">\(sum=sum+count\)</span> and <span class="math notranslate nohighlight">\(count=count-1\)</span>).
We can denote this by a function, call it <code class="docutils literal notranslate"><span class="pre">T</span></code>,
where <span class="math notranslate nohighlight">\(T(n)=2 + 2n\)</span>.
The parameter <em>n</em> is often referred to as
the “size of the problem,” and we can read this as “T(n) is the time
it takes to solve a problem of size n, namely 2+2n steps.”</p>
<p>In the summation functions given above, it makes sense to use the number
of terms in the summation to denote the size of the problem. We can then
say that the sum of the first 100,000 integers is a bigger instance of
the summation problem than the sum of the first 1,000. Because of this,
it might seem reasonable that the time required to solve the larger case
would be greater than for the smaller case. Our goal then is to show how
the algorithm’s execution time changes with respect to the size of the
problem.</p>
<p>Computer scientists prefer to take this analysis technique one step further.
It turns out that the exact number of operations is not as important as
determining the most dominant part of the <span class="math notranslate nohighlight">\(T(n)\)</span> function.
In other words, as the problem gets larger, some portion of the <span class="math notranslate nohighlight">\(T(n)\)</span>
function tends to overpower the rest.
This dominant term is what, in the end,
is used for comparison.
The <strong>order of magnitude</strong> function describes the part
of <span class="math notranslate nohighlight">\(T(n)\)</span> that increases the fastest as the value of <em>n</em> increases.
Order of magnitude is often called <strong>Big-O notation</strong> (for “order”) and
written as <span class="math notranslate nohighlight">\(O(f(n))\)</span>.
It provides a useful approximation to the actual number of
steps in the computation. The function <span class="math notranslate nohighlight">\(f(n)\)</span> provides a simple
representation of the dominant part of the original <span class="math notranslate nohighlight">\(T(n)\)</span>.</p>
<p>In the above example, <span class="math notranslate nohighlight">\(T(n)=2+2n\)</span>. As <em>n</em> gets large, the
constants will become less and less significant to the final result. If
we are looking for an approximation for <span class="math notranslate nohighlight">\(T(n)\)</span>, then we can drop
them and simply say that the running time is <span class="math notranslate nohighlight">\(O(n)\)</span>. It is
important to note that the constants are certainly significant for
<span class="math notranslate nohighlight">\(T(n)\)</span>. However, as <em>n</em> gets large, our approximation will be
just as accurate without it.</p>
<div class="admonition-try-this admonition">
<p class="admonition-title">Try This!</p>
<p>Prove to yourself that the recursive version of the summation
in <code class="docutils literal notranslate"><span class="pre">accumulate2</span></code> has the same <span class="math notranslate nohighlight">\(O(n)\)</span> performance as
<code class="docutils literal notranslate"><span class="pre">accumulate1</span></code>.</p>
</div>
<aside class="topic">
<p class="topic-title">Example</p>
<p>Suppose that for some algorithm, the exact number of
steps is <span class="math notranslate nohighlight">\(T(n)=5n^{2}+27n+1005\)</span>. When <em>n</em> is small, say 1 or 2,
the constant 1005 seems to be the dominant part of the function.
However, as <em>n</em> gets larger, the <span class="math notranslate nohighlight">\(n^{2}\)</span> term becomes the most
important. In fact, when <em>n</em> is really large, the other two terms become
insignificant in the role that they play in determining the final
result. Again, to approximate <span class="math notranslate nohighlight">\(T(n)\)</span> as <em>n</em> gets large, we can
ignore the other terms and focus on <span class="math notranslate nohighlight">\(5n^{2}\)</span>. In addition, the
coefficient <span class="math notranslate nohighlight">\(5\)</span> becomes insignificant as <em>n</em> gets large. We
would say then that the function <span class="math notranslate nohighlight">\(T(n)\)</span> has an order of
magnitude <span class="math notranslate nohighlight">\(f(n)=n^{2}\)</span>, or simply that it is <span class="math notranslate nohighlight">\(O(n^{2})\)</span>.</p>
</aside>
<p><strong>Self Check</strong></p>
<div id='tabbed_check1' data-component="tabbedStuff"  class='alert alert-warning '><div data-component="tab" data-tabname="Q1" >

    <div class="runestone ">
    <ul data-component="multiplechoice" data-question_label="1" data-multipleanswers="false"  id="bigo3"  style="visibility: hidden;">
    <p>sc-1-1: If the exact number of steps is <span class="math notranslate nohighlight">\(T(n)=2n+3n^{2}-1\)</span> what is the Big O?</p>

    <li data-component="answer"  id="bigo3_opt_a">O(2n)</li><li data-component="feedback">No, 3n<sup>2</sup> dominates 2n. Try again.</li>
    
    <li data-component="answer"  id="bigo3_opt_b">O(n)</li><li data-component="feedback">No, n<sup>2</sup> dominates n. Try again.</li>
    
    <li data-component="answer"  id="bigo3_opt_c">O(3n<sup>2</sup>)</li><li data-component="feedback">No, the 3 should be omitted because n<sup>2</sup> dominates.</li>
    
    <li data-component="answer" data-correct='yes' id="bigo3_opt_d">O(n<sup>2</sup>)</li><li data-component="feedback">Right!</li>
    
    <li data-component="answer"  id="bigo3_opt_e">More than one of the above</li><li data-component="feedback">No, only one of them is correct. Try again.</li>
    

    </ul>
    </div>
    </div><div data-component="tab" data-tabname="Q2" >

        <div class="runestone parsons-container ">
        <div data-component="parsons" id="parsonsBigO" class="parsons" >
        <div class="parsons_question parsons-text" >
    <p>Without looking at the graph above, from top to bottom order the following from most to least efficient.</p>

        </div>
        <pre  class="parsonsblocks" data-question_label="2"          style="visibility: hidden;">
        constant
logarithmic
linear
log linear
quadratic
cubic
exponential
        </pre>
        </div>
        </div>
    </div><div data-component="tab" data-tabname="Q3" >

    <div class="runestone ">
    <ul data-component="multiplechoice" data-question_label="3" data-multipleanswers="false"  id="crossoverefficiency"  style="visibility: hidden;">
    <p>sc-1-3: Which of the following statements is true about the two algorithms?
Algorithm 1: 100n + 1
Algorithm 2: n^2 + n + 1</p>

    <li data-component="answer"  id="crossoverefficiency_opt_a">Algorithm 1 will require a greater number of steps to complete than Algorithm 2</li><li data-component="feedback">This could be true depending on the input, but consider the broader picture</li>
    
    <li data-component="answer"  id="crossoverefficiency_opt_b">Algorithm 2 will require a greater number of steps to complete than Algorithm 1</li><li data-component="feedback">This could be true depending on the input, but consider the broader picture</li>
    
    <li data-component="answer" data-correct='yes' id="crossoverefficiency_opt_c">Algorithm 1 will require a greater number of steps to complete than Algorithm 2 until they reach the crossover point</li><li data-component="feedback">Correct!</li>
    
    <li data-component="answer"  id="crossoverefficiency_opt_d">Algorithm 1 and 2 will always require the same number of steps to complete</li><li data-component="feedback">No, the efficiency of both will depend on the input</li>
    

    </ul>
    </div>
    </div>
    </div>

</section>
<section id="using-summation-facts">
<h2>Using summation facts<a class="headerlink" href="#using-summation-facts" title="Permalink to this heading">¶</a></h2>
<p>Sometimes we can combine our knowledge of
asymptotic analysis and math facts to make algorithms more
efficient.</p>
<div id='tabbed_summation_facts' data-component="tabbedStuff"  class='alert alert-warning '><div data-component="tab" data-tabname="Sum" >
<p>Starting with the original accumulate algortihm.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>accumulate1<span class="o">(</span>int:<span class="w"> </span>N<span class="o">)</span>
<span class="w">   </span>sum<span class="w"> </span>←<span class="w"> </span><span class="m">0</span>
<span class="w">   </span>count<span class="w">  </span>←<span class="w"> </span>N
<span class="w">   </span><span class="k">while</span><span class="w"> </span>count<span class="w"> </span>&gt;<span class="w"> </span><span class="m">0</span>
<span class="w">      </span>sum<span class="w"> </span>←<span class="w"> </span>sum<span class="w"> </span>+<span class="w"> </span>count
<span class="w">      </span>count<span class="w"> </span>←<span class="w"> </span>count<span class="w"> </span>-<span class="w"> </span><span class="m">1</span>
<span class="w">   </span><span class="k">done</span><span class="w"> </span><span class="k">while</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span>sum
<span class="k">done</span><span class="w"> </span>accumulate
</pre></div>
</div>
<p>When we discussed <a class="reference internal" href="../math/summations.html"><span class="doc">Summations</span></a>,
we saw that is loop is equivalent to</p>
<div class="math notranslate nohighlight">
\[\sum_{k = 1}^{n} k = \frac{n (n+1)}{2}.\]</div>
<p>We can use this fact to transform
our <span class="math notranslate nohighlight">\(O(n)\)</span> algorithm into <span class="math notranslate nohighlight">\(O(1)\)</span>.
The cost of <span class="math notranslate nohighlight">\(O(1)\)</span> algorithms is <em>constant</em>.
<a class="reference internal" href="../glossary.html#term-constant-time"><span class="xref std std-term">Constant time</span></a> algorithms do not grow
more expensive as the size of <span class="math notranslate nohighlight">\(n\)</span> grows large.</p>
</div><div data-component="tab" data-tabname="Run It" >

<div class="runestone explainer ac_section ">
<div data-component="activecode" id=ac_analysis_accumulate_bigo data-question_label="4">
<div id=ac_analysis_accumulate_bigo_question class="ac_question">

</div>
<textarea data-lang="cpp" id="ac_analysis_accumulate_bigo_editor" 
      data-timelimit=25000     
    data-audio=''      
    data-compileargs="[&#x27;-Wall&#x27;, &#x27;-Wextra&#x27;, &#x27;-pedantic&#x27;, &#x27;-std=c++11&#x27;]"       data-wasm=/_static
     style="visibility: hidden;">
#include <ctime>
#include <iostream>

clock_t start() {
   return clock();
}
void time_since(clock_t start) {
   clock_t end = clock();
   double elapsed_secs = double(end - start) / CLOCKS_PER_SEC;
   std::cout << std::fixed
             << " took "<< elapsed_secs << " seconds\n";
}

long accumulate1(long n){
   long sum = 0;
   for (long i = n; i > 0; --i){
       sum = sum + i;
   }
   return sum;
}

long accumulate2(long n){
    return (n*(n+1))/2;
}

int main(){

    for (int N=1000; N<1e6; N*=10) {
       clock_t begin = clock();
       std::cout << "N: " << N
                 << ", Sum1 = " << accumulate1(N) << '\t';
       time_since(begin);
    }

    for (int N=1000; N<1e6; N*=10) {
       clock_t begin = clock();
       std::cout << "N: " << N
                 << ", Sum2 = " << accumulate2(N) << '\t';
       time_since(begin);
    }

    return 0;
}
</textarea>
</div>
</div>
</div>
    </div>

<p>There are two important things to notice about this output.
First, the times
recorded above are shorter than any of the previous examples. Second, they are
very consistent no matter what the value of <span class="math notranslate nohighlight">\(n\)</span>.
It appears that <code class="docutils literal notranslate"><span class="pre">accumulate2</span></code> is
hardly impacted by the number of integers being added.</p>
<p>But what does this benchmark really tell us? Intuitively, we can see that the
iterative solutions seem to be doing more work since some program steps are
being repeated.
This is likely the reason it is taking longer. Also, the time required for
the iterative solution seems to increase as we increase the value of <span class="math notranslate nohighlight">\(n\)</span>.
However, there is a problem.
If we run the same function on a different
computer or used a different programming language, we would get
different results. It could take even longer to perform <code class="docutils literal notranslate"><span class="pre">accumulate2</span></code>
if the computer were older.</p>
<p>Asymptotic analysis gives us the tools to definitively state,
without resorting to measuring execution time,
that the <code class="docutils literal notranslate"><span class="pre">accumulate2</span></code> runs in <a class="reference internal" href="../glossary.html#term-constant-time"><span class="xref std std-term">constant time</span></a>,
while the <code class="docutils literal notranslate"><span class="pre">accumulate1</span></code> function runs in <span class="math notranslate nohighlight">\(O(n)\)</span> time.</p>
</section>
<section id="pitfall-confusing-upper-bound-and-worst-case">
<h2>Pitfall: Confusing upper bound and worst case<a class="headerlink" href="#pitfall-confusing-upper-bound-and-worst-case" title="Permalink to this heading">¶</a></h2>
<p>A common mistake people make is confusing the upper bound and worst case
cost for an algorithm.
The upper bound represents the highest growth rate an
algorithm may have for size <span class="math notranslate nohighlight">\(n\)</span>.
The sequential search algorithm we discussed in <a class="reference internal" href="cases.html"><span class="doc">Best, worst, and average cases</span></a>
involved 3 key input cases:</p>
<ol class="arabic simple">
<li><p>When the target value was in the first element (base case)</p></li>
<li><p>When the target value was not found (worst case)</p></li>
<li><p>The average cost for all possible locations,
which works out to <span class="math notranslate nohighlight">\(n/2\)</span></p></li>
</ol>
<p>In the best case, only a single element is visited.
Accordingly, the upper bound for this algorithm in the
best case is <span class="math notranslate nohighlight">\(O(1)\)</span>.
Even when <span class="math notranslate nohighlight">\(n\)</span> grows large,
the cost for the base case is constant.</p>
<p>In the worst case, every element is visited.
Accordingly, the upper bound for this algorithm in the
worst case is <span class="math notranslate nohighlight">\(O(n)\)</span>.
No matter the value of <span class="math notranslate nohighlight">\(n\)</span>,
for some constant <span class="math notranslate nohighlight">\(c\)</span>, <span class="math notranslate nohighlight">\(cn\)</span> is bigger than <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>In the average case, about <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span> elements are visited.
The upper bound for this algorithm in the
average case is also <span class="math notranslate nohighlight">\(O(n)\)</span>.
As <span class="math notranslate nohighlight">\(n\)</span> grows large, the denominator becomes insignificant.
No matter the value of <span class="math notranslate nohighlight">\(n\)</span>,
for some constant <span class="math notranslate nohighlight">\(c\)</span>, <span class="math notranslate nohighlight">\(cn\)</span> is bigger than <span class="math notranslate nohighlight">\(n/2\)</span>.</p>
<p>Therefore, question we should always consider is:
<em>what is the upper bound of our algorithm in the best / average / worst case</em>?
And the answer should be (sequential search):</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(O(1)\)</span> in the <strong>best case</strong></p></li>
<li><p><span class="math notranslate nohighlight">\(O(n)\)</span> in the <strong>worst case</strong></p></li>
<li><p><span class="math notranslate nohighlight">\(O(n)\)</span> in the <strong>average case</strong></p></li>
</ul>
<div class="admonition-more-to-explore admonition">
<p class="admonition-title">More to Explore</p>
<ul class="simple">
<li><p>TBD</p></li>
</ul>
</div>
<aside class="topic">
<p class="topic-title">Acknowledgements</p>
<p>This section is adapted from
<a class="reference external" href="https://runestone.academy/runestone/books/published/cppds">Problem Solving with Algorithms and Data Structures using C++</a>,
by Brad Miller and David Ranum, Luther College, and Jan Pearce, Berea College
released under the
<a class="reference external" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>.</p>
</aside>
</section>
</section>


  

  <div id="scprogresscontainer">
    You have attempted <span id="scprogresstotal"></span> of <span id="scprogressposs"></span> activities on this page <div id="subchapterprogress" aria-label="Page progress"></div>
  </div>

  <ul role="navigation" class="nextprev-list nextprev-list" aria-label="Change page">
<li id="relations-prev" class="navLink" title='Previous Section - Best, worst, and average cases' data-toggle="tooltip">
  <a href="cases.html" aria-label="Previous - Best, worst, and average cases">
    <i class='prevNav glyphicon glyphicon-chevron-left'  style="top:50%; transform:translateY(-50%)translateX(-50%); left: 50%; color:black;"></i>
  </a>
</li>

  <li id="relations-next" class="navLink" title='Next Section - Lower Bounds' data-toggle="tooltip" >
    <a href="big-theta.html" aria-label="Next - Lower Bounds">
      <i id="relationsNextIcon" class='nextNav glyphicon glyphicon-chevron-right' style="top:50%; transform:translateY(-50%)translateX(-50%); left: 50%; color:black; "></i>
    </a>
  </li>
</ul>

<script>
window.addEventListener('load', (event) => {
  $('#relations-prev').tooltip({'placement': 'right', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement': 'left', 'delay': { show: 100, hide: 50}});
});
</script>

</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      
      | <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2024 Dave Parillo.
      Created using <a href="http://runestoneinteractive.org/">Runestone</a> 6.6.2.
    </p>
  </div>
</footer>




<script>
  window.addEventListener('load', (event) => {
    runestoneComponents.getSwitch();
  });
</script>


  </body>
</html>